{% extends "layout.html" %}
{% block content %}

<h2 class="hint">Walk-In Print Queue</h2>

<div style="margin-bottom:10px; display:flex; gap:8px;">
  <button class="queue-btn" onclick="loadQueue()">Refresh</button>
</div>

<table id="queue_table">
  <thead>
    <tr>
      <th>customer_code</th>
      <th>customer_name</th>
      <th>attendee_name</th>
      <th>Queued</th>  <!-- shows when the walk-in hit the booth queue -->
      <th style="width:120px;">Actions</th>
    </tr>
  </thead>
  <tbody id="qbody">
    <!-- rows inserted by JS -->
  </tbody>
</table>

<script>
  async function loadQueue() {
    let data = { items: [] };
    try {
      // If your backend supports it, this returns walk-ins only
      const res = await fetch('/api/queue?source=walkin', { credentials: 'same-origin' });
      data = await res.json();
    } catch (e) {}

    // Client-side safety net: keep only walk-ins
    const items = (data.items || []).filter(i => (i.source || '').toLowerCase() === 'walkin');

    const body = document.getElementById('qbody');
    body.innerHTML = '';

    if (!items.length) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="5" style="text-align:center; color:#666; padding:16px;">
        No walk-in badges in queue.
      </td>`;
      body.appendChild(tr);
      return;
    }

    items.forEach(q => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${escapeHtml(q.customer_code || '')}</td>
        <td>${escapeHtml(q.customer_name || '')}</td>
        <td>${escapeHtml(q.attendee_name || '')}</td>
        <td>${formatLocal(q.created_at_iso)}<div style="color:#6b7280; font-size:12px;">${timeAgo(q.created_at_iso)}</div></td>
        <td><button class="badge-btn" onclick="printBadge('${q.queue_id}')">Print</button></td>
      `;
      body.appendChild(tr);
    });
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[c]));
  }

  // Local timestamp like "10:42 AM 8/18/2025"
  function formatLocal(iso) {
    if (!iso) return '';
    const d = new Date(iso);
    const t = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const dat = d.toLocaleDateString();
    return `${t} ${dat}`;
  }

  // "x min ago"
  function timeAgo(iso) {
    if (!iso) return '';
    const now = Date.now();
    const then = new Date(iso).getTime();
    const diff = Math.max(0, Math.floor((now - then) / 1000));
    if (diff < 60) return `${diff}s ago`;
    const m = Math.floor(diff/60); if (m < 60) return `${m}m ago`;
    const h = Math.floor(m/60);    if (h < 24) return `${h}h ago`;
    const d = Math.floor(h/24);    return `${d}d ago`;
  }

  async function markPrinted(queueId) {
    try {
      await fetch('/api/queue/mark_printed', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({ queue_id: queueId }),
        credentials: 'same-origin'
      });
    } catch {}
  }

  function printBadge(queueId) {
    const w = window.open(`/badge/${queueId}`, '_blank', 'noopener,noreferrer');
    if (!w) return; // popup blocked

    const afterLoad = () => {
      try { w.focus(); } catch {}
      setTimeout(async () => {
        try { w.print(); } catch {}
        setTimeout(async () => {
          await markPrinted(queueId);
          try { w.close(); } catch {}
          loadQueue();
        }, 700);
      }, 250);
    };

    if (w.document && w.document.readyState === 'complete') {
      afterLoad();
    } else {
      w.onload = afterLoad;
    }
  }

  // Initial load
  loadQueue();
  // Optional polling:
  // setInterval(loadQueue, 10000);
</script>

{% endblock %}
